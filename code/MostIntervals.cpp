/**********************************************
  > File Name		: MostIntervals.cpp
  > Author			: lunar
  > Email			: lunar_ubuntu@qq.com
  > Created Time	: Sun 19 Jul 2020 01:52:48 PM CST
 ************************************************/

#include <iostream>
using namespace std;

/*
 * 给定一些区间，这些区间可能互相重叠，要求找出最大数量的互不重叠的区间
 * 
 * 这是一个我在Leetcode上面遇到过的问题，非常经典的找区间的问题，所以特意放到code文件夹里了。
 * 可以作为一个动态规划算法的示例代码。
 * 
 * 动态规划应该怎么做？
 * 动态规划的很大一部分问题都在于某样东西要不要取，比如背包问题。这时候我们就要比较取和不取哪个对整体最有利，但这不是贪心算法，贪心
 * 算法是在不改变前一步决定的前提下做出当前的最优决定。但是动态规划不一样，动态规划之前选取的东西都是暂定的，都是可以随时抛弃的，
 * 动态规划的每一次比较都是全局的范围内进行比较。
 * 
 * 具体问题具体分析
 * 对于这一系列区间，首先要确认它们是按照左端点排好序的。要不然做不了。
 * 然后我们需要一个例子：[1,7],[2,4],[3,5],[4,5],[6,9]
 * 易知最优解就是：[2,4],[4,5],[6,9]
 * 
 * 那么写代码应该怎么分析呢？
 * 首先遇到[1,7]，我们就知道在[1,7]范围内只有一个区间。
 * 然后是[2,4]，与[1,7]比较，选哪个都是只有一个区间，肯定是选后端点小的那个，为后面节省空间。
 * 所以可以得出我们的第一条规则：
 *     1. 当放弃所有重叠的区间选择当前区间 与 不选择当前区间得到的暂时的区间数量相同时，优先选择后端点小的。
 * 然后是[3,5]，同样的道理，选择[3,5]的话在[1,5]的范围内都只有一个区间，所以优先选择范围小的[2,4]
 * 然后是[4,5], 与之前的区间没有冲突，可以心安理得的将区间数量加1，然后将后端点延伸到5
 * 然后是[6,9]，继续加上去
 * 
 * 哦，突然想起来，如果将所有区间都排好序的话，是不可能出现一个后面的区间要横跨前面两个区间的。所以只需要考虑尽可能的用右端点近的
 * 区间就好了。
 */



