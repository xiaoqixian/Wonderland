### **AVL Tree**

---

#### **介绍**

AVL树和红黑树均属于自平衡树, 什么是自平衡树呢? 对于普通的二叉搜索树, 在随机插入数据的情况下, 树中的数据量与树的深度的关系是不确定的. 最好的情况是接近于二分查找, 时间复杂度为$\log_2n$. 但是大多数情况下的时间复杂度都大于此值. 所以为了使二叉树的查找的时间复杂度保持在$\log_2n$,  就出现了自平衡树.

自平衡树可以根据自身树的某种机制使得对于每个父节点都可以保持两个子树的深度不会相差太多. 这样就使得查找的复杂度一直保持在$\log_2n$附近.

对于AVL树, 这种机制是树的高度. 在AVL树中, 当两棵子树的深度相差超过1时就需要进行平衡操作, 即左旋和右旋操作. 

#### **左旋和右旋**

左旋和右旋是使得二叉树可以保持平衡的关键操作. 在逐渐插入数据的过程中, 容易出现两侧子树的深度的失衡. 左旋和右旋就是为了将这种失衡消除. 在进行左旋操作后, 当前节点的左子树的深度将加1, 右子树的深度减1.

左旋在右子树的深度大于左子树的深度时使用, 即将当前的父节点通过旋转更换到左子树中, 而父节点的右子节点变成新的父节点. 

具体代码为(假设node表示进行左旋操作的父节点):

```c
TreeNode* tmp = node->right;
node-.right = tmp->left;
tmp->left = node;
```

右旋是与左旋相对称的操作

#### **查找**

AVL树的查找与一般二叉搜索树的查找并无二异, 不讲.

#### **插入节点**

插入节点也不难, 通过递归调用, 总能找到一个这样的父节点, 插入节点要插入的位置对于该父节点时NULL. 于是就可以直接分配一个TreeNode结构体给插入节点.然后对该节点进行左旋或右旋操作进行平衡. 

其次, 在每一次递归中, 都需要更新当前节点的高度.

#### **删除节点**

删除节点稍微麻烦一点, 需要分多种情况.

首先要先找到要删除的节点. 对于要删除的节点有四种情况:

1. 节点是叶子节点, 则可以直接删除.
2. 节点有一个子节点是NULL, 则根据AVL树对于两子树的高度的限制, 另一个非NULL的子树的深度必定为1. 所以删除后当前节点也不需要做平衡操作, 直接让子节点顶替原节点的位置.
3. 如果两个子节点都不为NULL, 则需要向子树中借一个节点, 说是借, 其实就是复制子节点的值, 这样就相当于将原节点删除, 而子节点搬到了原父节点的位置. 然后递归调用删除节点函数将子节点删除.