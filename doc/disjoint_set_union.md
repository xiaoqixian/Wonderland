### **幷查集**

最近在做到Leetcode 399题：除法求值时，因为是图论分类的题目，所以就一直想着用深度优先搜索去解题，结果发现异常困难，而且想必解出来也是空间和时间双10%，然后看了一眼题解发现清一色地都是用**幷查集**解题。所以特来学习一下。

#### **基本介绍**

幷查集经常用于处理一些不相交集合的合并问题。如求最小生成树的Krusal算法等。

幷查集的核心思想在于通过一个集合的某个元素代表一个集合，通过某个元素，可以迅速地通过这个元素找到这个元素所在的集合（的根节点）。而且操作的时间复杂度是常数级的。

幷查集的基本操作有三个：

1. makeSet(s): 建立一个新的幷查集，含有s个元素
2. unionSet(x, y): 如果x和y所在的集合相交则合并，否则不合并。
3. find(x): 找到元素x所在的集合，可用于判断两个元素是否处在同一个集合。

#### 路径压缩

幷查集可以实现常数级时间查找的关键在于**路径压缩**。即每次在查找时，都会令路径上的每个节点都指向根节点。

![](https://images0.cnblogs.com/blog/358550/201309/12160922-bc21dc9e11d645519c158e4f5153e20d.png)

要实现这一点，首先容易想到的是递归版本。判断前一个节点的前一个节点是否是root节点，如果是，则直接指向它。否则递归调用前一个节点。

那么对于非递归版本，就必须要先从本节点向上遍历找到root节点，然后再从本节点向上遍历，遍历的每个节点都要指向root节点。

之所以有这个操作是因为幷查集经常有合并操作，所以对于每次合并，在下一次查找时都可能要进行find操作。

#### **合并操作**

所谓合并，无非是将一个集合的根节点指向一个另一个集合的根节点。一般为了减少操作，总是将深度小的树指向深度大的树。

#### **题目**

看到这里，可能还想不到这个题目和幷查集有什么关系。其实最大的关系就在于要判断算式的分子分母是否可以计算，直接判断两者是否在同一个幷查集中就可以。

所以对于任意两个要求计算的节点，首先观察它们是否处于一个幷查集中。如果不是，就可以直接得出无法计算。

如果是的话，就要让两个变量一路向上，假设是求`a/b`，则分别找到`a/root`和`b/root`的结果，则`a/b = a/root/b/root`。所以过程就非常明了了。

现在就要想如何根据已知的计算结果构造幷查集。这里选择用两个map来分别表示子节点的父节点和子节点到父节点的权值。

但是这个方法有一个问题无法解决，就是一个变量可能对应多个算式，如a/b = x,a/c = y，这样就无法讲所有结果串起来，只能再计算b/c，讲结果串起来。

但是这里用幷查集做时，因为节点之间存在逻辑关系，所以**在通过压缩路径来缩短时间时，相应的权值也需要改变。**

#### **参考:[幷查集-CYJB](https://www.cnblogs.com/cyjb/p/UnionFindSets.html)**