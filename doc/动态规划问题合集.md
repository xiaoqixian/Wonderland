# 动态规划问题合集

### 反向背包问题

背包问题的本质是：对于一个数组，选取数组的一个可非连续子数组，在保证子数组之和不超过某个阈值的情况下，使得子数组之和最大。

如果将条件倒过来，就可以得到一个反向背包问题。

问题描述：选取数组的一个可非连续子数组，在保证子数组之和**大于等于**某个阈值的情况下，使得子数组之和**最小**。

解决方案：同样使用动态规划，背包问题是从第0件物品开始选取，dp[i] 数组表示在前 i 件物品可选的情况下的各价值阈值下的最优情况。对于反向背包问题，则假设一开始拥有全部物品，然后从第0件物品开始丢弃，dp[i] 数组表示在前 i 件物品可丢弃的情况下的各阈值下的最优情况。

递推公式
$$
dp[i][j] = \min(dp[i-1][j], dp[i-1][j+nums[i]] - nums[i])
$$


### 最大子数组和问题

问题描述：对于一个有正有负的数组nums，求其最大连续子数组之和。

解决方案：dp[i] 表示 nums[0..i] 中以 i 结尾的最大子数组之和，则递推公式
$$
dp[i] = \max(dp[i-1] + nums[i], nums[i])
$$

### 卖木头问题

问题描述：对于一个矩形木块，可以将其任意横向或纵向切割；给定一些特定高和宽的木块可以卖出的价格，并且卖多个同样尺寸的木块，求该矩形木块可以卖出的最大价格。

解决方案：其实这个问题集合了二维动态规划和多重背包问题。用二维数组 dp\[h\]\[w\] 表示高和宽为 h 和 w 的木头可以卖出的最大价格，使用第一块可以卖出的木头对 dp 进行初始化，然后对于接下来的每个木头，dp 可以表示在 前 k-1 块木头的选择下可以卖出的最大价格。由于同一个尺寸的木头可以卖出多次，因此需要遍历在 h 和 w 的范围内，比较卖出 hn * wn 块 k 木头与不卖的价格，则对于第 k 块木头的递推公式
$$
dp[h][w] = \max(dp[h][w], hn*wn*price + \mathrm{max\_remain})\\
\mathrm{max\_remain} = \max(dp[h-th][w] + dp[th][w-tw],\\ dp[h][w-tw]+dp[h-th][tw])
$$
式中，

- hn: 纵向卖出的木头数量
- wn: 横向卖出的木头数量
- price：第k块木头的价格
- th: th = hn * height, height 为 第 k 块的高
- tw: tw = wn * width, width 为 第 k 块的宽

### 分饼干问题

问题描述：有 n 包饼干，每包饼干的数量不一致，有 k 个小朋友，每包饼干只能分配给一个小朋友，问如何分配可以使得获得最多饼干的小朋友的饼干数量最少。

解决方案：
